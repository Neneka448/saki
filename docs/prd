```plaintext
这是系统第二阶段的核心定义文档。
本文档仅聚焦于**尚未实现**或**需要深度升级**的核心能力，已完成的基础功能（如项目管理、基础卡片录入、标签管理、基础 AI 对话、快速记录）不再赘述。

本阶段的核心目标是：**从“碎片化记录”进化为“系统化知识构建”**。
我们要解决用户在阅读源码、深度研究时，“记了但串不起来”、“代码与笔记脱节”、“无法输出完整文章”的痛点。

⸻

**1. 代码锚点 (Code Anchors)：让知识“落地”**

在当前系统中，卡片是纯文本的。但在源码阅读场景下，卡片必须能“挂载”在具体的代码行上。
系统需要引入“代码锚点”的概念，作为卡片的一种核心属性。

*   **源码引用**：用户在创建或编辑卡片时，可以指定该卡片关联的本地文件路径及行号范围（例如 `src/main.ts:10-20`）。
*   **快照机制**：考虑到源码会变动，系统在建立锚点时，必须自动抓取并保存该段代码的**文本快照**。在展示时，优先展示快照（保证笔记上下文的稳定性），同时提供“对比最新代码”的能力。
*   **双向跳转**：
    *   **笔记 -> 代码**：点击卡片上的锚点，系统应通过 `vscode://` 协议唤起 VS Code 并自动跳转到对应行。
    *   **代码 -> 笔记**（未来规划）：理想情况下，IDE 插件能反向显示“这里有一张卡片”，但在本阶段，我们优先保证从笔记到代码的单向流畅体验。

⸻

**2. 显式关联与图谱 (Explicit Relations & Graph)**

标签（Tag）解决了“分类”问题，但解决不了“逻辑”问题。
在分析复杂系统时，用户需要表达“函数 A 调用了 函数 B”、“模块 C 继承自 模块 D”这种明确的逻辑关系。

系统需要引入**“显式关联”**机制：
*   **强类型连接**：卡片之间不再只有“同标签”这种弱关联，而是可以建立明确的指向性连接。基础关系类型包括：`前置/后置`（流程）、`引用/被引用`（依赖）、`父/子`（层级）。
*   **双链自动建议**：当用户在卡片正文中输入 `[[` 并引用另一张卡片时，系统应自动建立一条默认的“引用”关系，无需用户手动去配置关系属性。

基于这些关系，系统需要提供**“局部图谱”**能力：
*   不追求展示全库几千张卡片的“大爆炸”视图。
*   重点展示**“当前关注点”**的上下文：当我看卡片 A 时，系统应展示 A 的上游（谁调用了它）和下游（它调用了谁），帮助用户理清局部脉络。

⸻

**3. 拼接工作台 (The Composer)：从卡片到文章**

这是本阶段最重要的功能升级。
目前的系统只能“记”，不能“写”。用户积累了大量卡片后，缺乏一个环境将它们串联成一篇完整的技术文档或博客。

系统需要引入一个新的核心工作模式：**拼接工作台 (Composer)**。
这是一个专为“知识合成”设计的环境，它打破了“一张卡片一个编辑器”的限制，提供“素材库 + 画布”的双栏工作流。

*   **素材流（左栏）**：用户可以选择一个或多个标签（例如 `#项目A/网络层`），系统将所有相关卡片以紧凑的卡片流形式展示在左侧。这里是用户的“积木仓库”。
*   **合成区（右栏）**：这是一个长文编辑器。用户可以将左侧的卡片**拖拽**到右侧。
    *   拖拽后，系统不只是复制文本，而是插入一个**“引用块”**。
    *   用户可以在引用块之间编写连接性的文字、总结或补充。
*   **AI 辅助合成**：在工作台中，AI 的角色升级为“编辑助理”。用户可以选中左侧的 5 张卡片，对 AI 说：“帮我把这 5 张卡片的内容总结成一段关于初始化流程的描述，放在右边”，AI 生成后直接插入合成区。

⸻

**4. 嵌套标签与结构化侧边栏**

随着记录深入，平铺的标签列表已无法满足需求。
系统需要升级标签系统，支持**嵌套结构**（Nested Tags）。

*   **路径式标签**：支持 `工作/项目A/后端/API` 这样的路径命名。
*   **树形导航**：侧边栏不再是标签云，而是一个可折叠的**目录树**。这给用户一种“文件夹”的熟悉感和秩序感，但底层依然保持标签的灵活性（一张卡片可以同时挂在两棵树下）。

⸻

总结：
第二阶段的系统，不再仅仅是一个“记事本”。
它通过**代码锚点**连接现实世界（源码），通过**显式关联**构建逻辑网络，最后通过**拼接工作台**输出结构化知识。这构成了一个完整的“输入-整理-输出”闭环。
```
